#! /usr/bin/env python

import os
import argparse
import sys
import json
import logging
from logging import config
from tqdm import tqdm

import ndex2

from ndexutil.config import NDExUtilConfig
import ndexindraloader
from ndexindraloader.exceptions import NDExIndraLoaderError
from ndexindraloader.indra import Indra


logger = logging.getLogger(__name__)

TSV2NICECXMODULE = 'ndexutil.tsv.tsv2nicecx2'

LOG_FORMAT = "%(asctime)-15s %(levelname)s %(relativeCreated)dms " \
             "%(filename)s::%(funcName)s():%(lineno)d %(message)s"


class Formatter(argparse.ArgumentDefaultsHelpFormatter,
                argparse.RawDescriptionHelpFormatter):
    pass


def _parse_arguments(desc, args):
    """
    Parses command line arguments
    :param desc:
    :param args:
    :return:
    """
    parser = argparse.ArgumentParser(description=desc,
                                     formatter_class=Formatter)
    parser.add_argument('--profile', help='Profile in configuration '
                                          'file to use to load '
                                          'NDEx credentials which means'
                                          'configuration under [XXX] will be'
                                          'used ',
                        default='ndexindraloader')
    parser.add_argument('input',
                        help='Network(s) to annotate. Input can be one of '
                             'the following: ' +
                             'CX file, '
                             'Text file with NDEx network IDs one per line')
    parser.add_argument('--indracachedir',
                        help='If set, code will look in this directory for '
                             'previous output of Indra REST call for a given '
                             'network and use that instead of making the '
                             'call. If no output exists, the REST query '
                             'is made and the results are saved here.')
    parser.add_argument('--saveasfile',
                        help='If set, writes Indra annotated networks as CX '
                             'under directory specified by the value of this '
                             'flag. If directory does not exist it will be '
                             'created')
    parser.add_argument('--savetoserver', action='store_true',
                        help='NOT IMPLEMENTED. WILL RAISE ERROR!!! '
                             'If set, saves networks to NDEx server set via '
                             '--profile configuration. For additional options '
                             'see --dest_networkset, --visibility flags')
    parser.add_argument('--dest_networkset',
                        help='NOT IMPLEMENTED. WILL RAISE ERROR!!! '
                             'If set, adds annotated networks to NDEx '
                             'NetworkSet with UUID passed in. Ignored '
                             'unless --savetoserver is set')
    parser.add_argument('--visibility', choices=['private',
                                                 'public_not_searchable',
                                                 'public'],
                        help='NOT IMPLEMENTED. WILL RAISE ERROR!!! '
                             'If set, defines visibility for networks '
                             'uploaded to NDEx. Ignored unless --savetoserver '
                             'is set')
    parser.add_argument('--showcased', action='store_true',
                        help='NOT IMPLEMENTED. WILL RAISE ERROR!!!'
                             'If set, defines whether upload networks'
                             'are showcased on NDEx. Ignored unless '
                             '--savetoserver is set')
    parser.add_argument('--netprefix', default='Indra annotated - ',
                        help='Text prepended to network name for networks '
                             'generated by this tool')
    parser.add_argument('--minevidencecount', default=3, type=int,
                        help='Minimum evidence count needed to keep edge '
                             'statement')
    parser.add_argument('--maxnetworksize', type=int, default=100,
                        help='Maximum number of nodes that can be in the '
                             'input network. Values exceeding this will '
                             'cause script skip the network and will cause'
                             'tool to skip network and log an error '
                             'level message')
    parser.add_argument('--remove_orig_edges', action='store_true',
                        help='If set, all original edges are removed')
    parser.add_argument('--disable_tqdm', action='store_true',
                        help='If set, disables tqdm progress bars')
    parser.add_argument('--logconf', default=None,
                        help='Path to python logging configuration file in '
                             'this format: https://docs.python.org/3/library/'
                             'logging.config.html#logging-config-fileformat '
                             'Setting this overrides -v parameter which uses '
                             ' default logger.')

    parser.add_argument('--conf', help='Configuration file to load '
                                       '(default ~/' +
                                       NDExUtilConfig.CONFIG_FILE + ')')
    parser.add_argument('--verbose', '-v', action='count', default=1,
                        help='Increases verbosity of logger to standard '
                             'error for log messages in this module and'
                             'in ' + TSV2NICECXMODULE + '. Messages are '
                             'output at these python logging levels '
                             '-v = ERROR, -vv = WARNING, -vvv = INFO, '
                             '-vvvv = DEBUG, -vvvvv = NOTSET (default no '
                             'logging)')
    parser.add_argument('--version', action='version',
                        version=('%(prog)s ' +
                                 ndexindraloader.__version__))

    return parser.parse_args(args)


def _setup_logging(args):
    """
    Sets up logging based on parsed command line arguments.
    If args.logconf is set use that configuration otherwise look
    at args.verbose and set logging for this module and the one
    in ndexutil specified by TSV2NICECXMODULE constant
    :param args: parsed command line arguments from argparse
    :raises AttributeError: If args is None or args.logconf is None
    :return: None
    """

    if args.logconf is None:
        level = (50 - (10 * args.verbose))
        logging.basicConfig(format=LOG_FORMAT,
                            level=level)
        logging.getLogger(TSV2NICECXMODULE).setLevel(level)
        logger.setLevel(level)
        return

    # logconf was set use that file
    logging.config.fileConfig(args.logconf,
                              disable_existing_loggers=False)


def get_next_network_from_input(input, cachedir=None, server=None, username=None,
                                password=None):
    """
    Generator to get networks from `input` which can be a path to a
    single CX file or a file containing a list of NDEx network UUIDs
    one per line

    :param input: Path to a single CX file or a file
                  containing a list of NDEx network UUIDs
    :type input: str
    :return: (:py:class:`ndex2.nice_cx_network.NiceCXNetwork,
              CX file name or NDEx UUID)
    :rtype: tuple
    """

    # if input is a file
    if os.path.isfile(input):
        # and ends with .cx assume it is a CX file and load that
        if input.lower().endswith('.cx'):
            net_cx = ndex2.create_nice_cx_from_file(input)
            file_name = os.path.basename(input)
            cache_file = None
            if cachedir is not None:
                cache_file = os.path.join(cachedir,
                                          file_name + '.json')
                if not os.path.isfile(cache_file):
                    cache_file = None
            yield (net_cx, file_name, cache_file)
            return

        # otherwise assume file is a list of NDEx network ids
        with open(input, 'r') as f:
            for line in f:
                clean_line = line.rstrip()
                if len(clean_line) < 36:
                    continue
                net_cx = ndex2.create_nice_cx_from_server(server=server,
                                                          username=username,
                                                          password=password,
                                                          uuid=clean_line)
                cache_file = None
                if cachedir is not None:
                    cache_file = os.path.join(cachedir,
                                              clean_line + '.json')
                    if not os.path.isfile(cache_file):
                        cache_file = None
                yield net_cx, clean_line, cache_file
        return

    raise NDExIndraLoaderError('Input must be a CX file ending with .cx or '
                               'a file with NDEx Network UUID one per line')
    # TODO: add support to load single NDEx UUID and NetworkSet UUID
    # input is not a file so let's try to load it as a straight network

    # if above fails try to load entry as a networkset
    # and iterate through all the network ids


class NDExIndraLoader(object):
    """
    Class to load content
    """
    def __init__(self, args):
        """

        :param args:
        """
        self._conf_file = args.conf
        self._profile = args.profile
        self._user = None
        self._pass = None
        self._server = None
        self._args = args

    def _parse_config(self):
            """
            Parses config
            :return:
            """
            ncon = NDExUtilConfig(conf_file=self._conf_file)
            con = ncon.get_config()
            self._user = con.get(self._profile, NDExUtilConfig.USER)
            self._pass = con.get(self._profile, NDExUtilConfig.PASSWORD)
            self._server = con.get(self._profile, NDExUtilConfig.SERVER)

    def _create_saveasfile_dir(self):
        """

        :return:
        """
        if self._args.saveasfile is not None:
            outdir = os.path.abspath(self._args.saveasfile)
            if not os.path.isdir(outdir):
                logger.debug('Creating directory: ' + outdir)
                os.makedirs(outdir, mode=0o755)
            return outdir
        return None

    def _create_indracache(self):
        """

        :return:
        """
        if self._args.indracachedir is not None:
            cachedir = os.path.abspath(self._args.indracachedir)
            if not os.path.isdir(cachedir):
                logger.debug('Creating indra cache directory')
                os.makedirs(cachedir, mode=0o755)
            return cachedir
        return None

    def run(self):
        """
        Runs content loading for NDEx Indra Content Loader
        :param theargs:
        :return:
        """
        self._parse_config()
        if self._args.savetoserver is True:
            raise NDExIndraLoaderError('--savetoserver is not yet supported')

        cachedir = self._create_indracache()
        outdir = self._create_saveasfile_dir()

        t_progress = tqdm(desc='Indra annotate', unit=' tasks',
                          disable=self._args.disable_tqdm)
        indra = Indra()
        for net_tuple in get_next_network_from_input(self._args.input,
                                                     cachedir=cachedir,
                                                     server=self._server,
                                                     username=self._user,
                                                     password=self._pass):

            logger.debug('Processing: ' + net_tuple[0].get_name())

            num_nodes = len(net_tuple[0].get_nodes())
            if num_nodes > self._args.maxnetworksize:
                logger.error('Network has ' + str(num_nodes) +
                             ' which exceeds ' + str(self._args.maxnetworksize) +
                             '. To increase set --maxnetworksize flag')
            if net_tuple[2] is None:
                save_indra_res = True
                indra_data = None
            else:
                with open(net_tuple[2], 'r') as f:
                    indra_data = json.load(f)
                logger.info('Using cached indra version: ' + net_tuple[2])
                save_indra_res = False

            net_cx, indra_res = indra.annotate_network(net_cx=net_tuple[0],
                                                       indraresult=indra_data)
            if outdir is not None:
                outfile = os.path.join(outdir,
                                       net_tuple[1] + '.cx')
                logger.debug('Saving network to file: ' + outfile)
                with open(outfile, 'w') as f:
                    json.dump(net_cx.to_cx(), f)

            if save_indra_res is True:
                if cachedir is not None:
                    outfile = os.path.join(cachedir,
                                           net_tuple[1] + '.json')
                    logger.debug('Saving indra json to file: ' + outfile)
                    with open(outfile, 'w') as f:
                        json.dump(indra_res, f)
            t_progress.update()

        t_progress.close()

        return 0


def main(args):
    """
    Main entry point for program
    :param args:
    :return:
    """
    desc = """
    Version {version}

    Annotates NDEx with Indra and optionally loads networks into 
    NDEx (http://ndexbio.org).
    
    To connect to NDEx server a configuration file must be passed
    into --conf parameter. If --conf is unset the configuration 
    the path ~/{confname} is examined. 
         
    The configuration file should be formatted as follows:
         
    [<value in --profile (default ndexindraloader)>]
         
    {user} = <NDEx username>
    {password} = <NDEx password>
    {server} = <NDEx server(omit http) ie public.ndexbio.org>
    
    
    
    
    """.format(confname=NDExUtilConfig.CONFIG_FILE,
               user=NDExUtilConfig.USER,
               password=NDExUtilConfig.PASSWORD,
               server=NDExUtilConfig.SERVER,
               version=ndexindraloader.__version__)
    theargs = _parse_arguments(desc, args[1:])
    theargs.program = args[0]
    theargs.version = ndexindraloader.__version__

    try:
        _setup_logging(theargs)
        loader = NDExIndraLoader(theargs)
        return loader.run()
    except Exception as e:
        logger.exception('Caught exception: ' + str(e))
        return 2
    finally:
        logging.shutdown()


if __name__ == '__main__':  # pragma: no cover
    sys.exit(main(sys.argv))
